## EF Core & APIs

#### Entity Framework Core
 * Entity Framework (EF) Core is a lightweight, extensible, open source and cross-platform version of the popular Entity Framework data access technology.
	* EF Core can serve as an object-relational mapper (O/RM), enabling .NET developers to work with a database using .NET objects, and eliminating the need for most of the data-access code they usually need to write.

	#### The Model
	* With EF Core, data access is performed using a model. A model is made up of entity classes and a context object that represents a session with the database, allowing you to query and save data. See Creating a Model to learn more.
	* You can generate a model from an existing database, hand code a model to match your database, or use EF Migrations to create a database from your model, and then evolve it as your model changes over time.

#### Data Seeding
	* Data seeding is the process of populating a database with an initial set of data.
- There are several ways this can be accomplished in EF Core:
	* Model seed data
	* Manual migration customization
	* Custom initialization logic
- EF Core, seeding data can be associated with an entity type as part of the model configuration. Then EF Core migrations can automatically compute what insert, update or delete operations need to be applied when upgrading the database to a new version of the model.
- You can use context.Database.EnsureCreated() to create a new database containing the seed data, for example for a test database or when using the in-memory provider or any non-relation database. Note that if the database already exists, EnsureCreated() will neither update the schema nor seed data in the database. For relational databases you shouldn't call EnsureCreated() if you plan to use Migrations.

#### Limitations of model seed data
 * This type of seed data is managed by migrations and the script to update the data that's already in the database needs to be generated without connecting to the database. This imposes some restrictions:
	* The primary key value needs to be specified even if it's usually generated by the database. It will be used to detect data changes between migrations.
	* Previously seeded data will be removed if the primary key is changed in any way.
Therefore this feature is most useful for static data that's not expected to change outside of migrations and does not depend on anything else in the database, for example ZIP codes.
- If your scenario includes any of the following it is recommended to use custom initialization logic described in the last section:

 * Temporary data for testing
* Data that depends on database state
* Data that needs key values to be generated by the database, including entities that use alternate keys as the identity
* Data that requires custom transformation (that is not handled by value conversions), such as some password hashing
* Data that requires calls to external API, such as ASP.NET Core Identity roles and users creation
* Manual migration customization

#### How to add User Secrets to .NET Core through Visual Studio
	* What is User secrets? User secrets is a secure way of storing private user information such as API keys, client secrets, and connection strings. Essentially anything that you don’t want others to know about when using your code base.
	* The user secrets is not uploaded to any source control. This ensures your keys do in fact stay “secret” to your local machine.
- Enabling User Secrets
	* Your first step is to enable User Secrets in your project. To do this, follow these steps:
	* Right click on your project
	* Select “Manage User Secrets”
	* This will open up a secrets.Json file in your Visual studio. Yours will be empty, but all it is, is a JSON key/value pair file. This should mimic your appsettings.json file.
